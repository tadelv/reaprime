---
phase: 02-integration-error-detection
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/main.dart
  - lib/src/services/webserver/logs_handler.dart
  - lib/src/services/webserver_service.dart
autonomous: true

must_haves:
  truths:
    - "System information (OS, device model, app version) appears as custom keys in every error report"
    - "GET /api/v1/logs returns the current log buffer contents as plain text"
    - "Log export works without triggering telemetry upload"
  artifacts:
    - path: "lib/main.dart"
      provides: "System info custom keys set on startup"
      contains: "device_info_plus"
    - path: "lib/src/services/webserver/logs_handler.dart"
      provides: "REST endpoint for log export"
      contains: "class LogsHandler"
    - path: "lib/src/services/webserver_service.dart"
      provides: "LogsHandler registered in router"
      contains: "logsHandler"
  key_links:
    - from: "lib/main.dart"
      to: "lib/src/services/telemetry/telemetry_service.dart"
      via: "setCustomKey for system info"
      pattern: "telemetryService\\.setCustomKey.*os_"
    - from: "lib/src/services/webserver/logs_handler.dart"
      to: "lib/src/services/telemetry/log_buffer.dart"
      via: "LogBuffer.getContents() for REST response"
      pattern: "logBuffer\\.getContents"
---

<objective>
Add system information snapshots to error reports and create the REST log export endpoint.

Purpose: System info (OS version, device model, app version) provides critical context for diagnosing platform-specific issues. The log export endpoint enables on-demand debugging without requiring telemetry consent or upload.

Output: System info custom keys set on every app startup; GET /api/v1/logs endpoint returning log buffer contents.
</objective>

<execution_context>
@/Users/vid/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-telemetry-service-privacy/01-02-SUMMARY.md

@lib/src/services/telemetry/telemetry_service.dart
@lib/src/services/telemetry/log_buffer.dart
@lib/main.dart
@lib/src/services/webserver_service.dart
@lib/src/services/webserver/feedback_handler.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Set system information custom keys on startup using device_info_plus</name>
  <files>
    lib/main.dart
  </files>
  <action>
In `lib/main.dart`, after telemetryService.initialize() succeeds (around line 133), add a system info collection block:

- Import `package:device_info_plus/device_info_plus.dart`
- Create a helper function `Future<void> _setSystemInfoKeys(TelemetryService telemetryService)` at the top level (or inline in main):
  - Use `DeviceInfoPlugin().deviceInfo` to get `BaseDeviceInfo`.
  - Set custom keys from the device info data map. The approach should be platform-adaptive:
    - `await telemetryService.setCustomKey('os_name', Platform.operatingSystem)`
    - `await telemetryService.setCustomKey('os_version', Platform.operatingSystemVersion)`
    - From the deviceInfo.data map, extract and set:
      - `app_version`: Use `BuildInfo.commitShort` (already imported)
      - `device_model`: Use `deviceInfo.data['model'] ?? deviceInfo.data['computerName'] ?? 'unknown'`
      - `device_brand`: Use `deviceInfo.data['brand'] ?? deviceInfo.data['hostName'] ?? 'unknown'`
  - Wrap in try-catch; if device_info_plus fails, log a warning and continue (non-blocking).

- Call `_setSystemInfoKeys(telemetryService)` after the telemetryService.initialize() try-catch block (fire and forget with `.catchError` or just await with try-catch). This should NOT block app startup if it fails.

Note: `device_info_plus` is already in pubspec.yaml (version ^12.3.0). No dependency changes needed.
  </action>
  <verify>
Run `flutter analyze lib/main.dart` -- no errors.
Verify main.dart imports device_info_plus and calls setCustomKey for os_name, os_version, device_model, device_brand, app_version.
  </verify>
  <done>
System information is set as custom keys on every app startup. All subsequent error reports automatically include OS, device model, and app version. LOGC-03 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GET /api/v1/logs endpoint and wire into webserver</name>
  <files>
    lib/src/services/webserver/logs_handler.dart
    lib/src/services/webserver_service.dart
    lib/main.dart
  </files>
  <action>
Create `lib/src/services/webserver/logs_handler.dart`:
- This file MUST use `part of '../webserver_service.dart';` at the top (following the existing handler pattern -- all handlers are `part` files of webserver_service.dart).
- Class `LogsHandler` with a `LogBuffer _logBuffer` field passed via constructor.
- Method `void addRoutes(RouterPlus app)` that registers `GET /api/v1/logs` -> `_handleGetLogs`.
- Method `Future<Response> _handleGetLogs(Request request)` that:
  - Calls `_logBuffer.getContents()` to get the log buffer string.
  - Returns `Response.ok(contents, headers: {'content-type': 'text/plain'})`.
  - This is intentionally simple per the user's locked decision: no filtering, no pagination.

Modify `lib/src/services/webserver_service.dart`:
- Add `part 'webserver/logs_handler.dart';` after the existing part directives (around line 55).
- In `startWebServer()`, create `final logsHandler = LogsHandler(logBuffer: logBuffer);` -- but LogBuffer is not currently passed to startWebServer. Need to add it as a parameter.
- Update `startWebServer` signature to accept `LogBuffer logBuffer` as an additional parameter.
- Pass `logsHandler` to `_init()`.
- Update `_init()` signature to accept `LogsHandler logsHandler` and call `logsHandler.addRoutes(app)`.

Modify `lib/main.dart`:
- Update the `startWebServer(...)` call (around line 274) to pass `logBuffer` as the additional parameter. `logBuffer` is already in scope from line 125.

Important: The log export returns the raw buffer contents. It does NOT trigger any telemetry upload. It does NOT scrub PII (the buffer already contains scrubbed WARNING+ messages, but also may contain non-scrubbed lower-level messages if added directly). For Phase 2, return as-is -- the endpoint is for local/API debugging, not for telemetry upload.
  </action>
  <verify>
Run `flutter analyze lib/src/services/webserver/logs_handler.dart lib/src/services/webserver_service.dart lib/main.dart` -- no errors.
Verify LogsHandler class exists with addRoutes registering GET /api/v1/logs.
Verify startWebServer accepts and passes LogBuffer through to LogsHandler.
Verify `part 'webserver/logs_handler.dart';` is in webserver_service.dart.
  </verify>
  <done>
GET /api/v1/logs returns log buffer contents as plain text. Works without telemetry consent or upload. REST endpoint satisfies the log export requirement from Phase 2 success criteria.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze lib/main.dart lib/src/services/webserver_service.dart lib/src/services/webserver/logs_handler.dart` passes with no errors
2. System info custom keys (os_name, os_version, device_model, device_brand, app_version) set after telemetry initialization
3. GET /api/v1/logs route registered and returns log buffer contents with text/plain content type
4. LogBuffer passed from main.dart through startWebServer to LogsHandler
5. No telemetry upload triggered by log export endpoint
</verification>

<success_criteria>
- System information snapshot appears in all error reports via custom keys set at startup
- GET /api/v1/logs returns the 16kb rolling log buffer as plain text
- Log export works independently of telemetry consent (reads local buffer only)
- No new dependencies added (device_info_plus already in pubspec.yaml)
</success_criteria>

<output>
After completion, create `.planning/phases/02-integration-error-detection/02-02-SUMMARY.md`
</output>
