---
phase: 03-performance-optimization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/src/services/telemetry/log_buffer.dart
  - lib/src/services/telemetry/telemetry_report_queue.dart
  - lib/src/services/telemetry/firebase_crashlytics_telemetry_service.dart
  - lib/main.dart
autonomous: true

must_haves:
  truths:
    - "LogBuffer enforces 16kb byte-size limit by actually evicting oldest entries (not breaking out of the while loop)"
    - "Telemetry error reports are deferred to a bounded queue rather than sent synchronously on the UI thread"
    - "When queue is full (10 reports), oldest report is evicted (FIFO) to make room for newest"
    - "Rate limiter remains as first line of defense before queue"
  artifacts:
    - path: "lib/src/services/telemetry/log_buffer.dart"
      provides: "Fixed size enforcement in append()"
      contains: "_buffer.toList"
    - path: "lib/src/services/telemetry/telemetry_report_queue.dart"
      provides: "Bounded async report queue with FIFO eviction"
      contains: "class TelemetryReportQueue"
    - path: "lib/src/services/telemetry/firebase_crashlytics_telemetry_service.dart"
      provides: "Queue-based recordError that defers Firebase calls"
    - path: "lib/main.dart"
      provides: "Queue wired into error reporting pipeline"
  key_links:
    - from: "lib/main.dart"
      to: "lib/src/services/telemetry/telemetry_report_queue.dart"
      via: "Queue created and passed to telemetry service or used in Logger.root listener"
      pattern: "TelemetryReportQueue"
    - from: "lib/src/services/telemetry/firebase_crashlytics_telemetry_service.dart"
      to: "lib/src/services/telemetry/telemetry_report_queue.dart"
      via: "recordError enqueues instead of awaiting Firebase directly"
      pattern: "_queue"
---

<objective>
Fix the LogBuffer size enforcement bug and add a bounded async report queue so telemetry never blocks the UI thread during scan/connect flows.

Purpose: The LogBuffer has a known bug where the while loop breaks immediately instead of evicting entries. The report queue ensures that Firebase Crashlytics calls (which involve platform channel IPC) never run synchronously during time-sensitive BLE operations. Together these fulfill the "UI always wins" degradation strategy.

Output: Fixed LogBuffer with working byte-size eviction, TelemetryReportQueue class with bounded capacity and FIFO eviction, and wired integration in main.dart.
</objective>

<execution_context>
@/Users/vid/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-performance-optimization/03-CONTEXT.md
@.planning/phases/01-core-telemetry-service-privacy/01-01-SUMMARY.md
@lib/src/services/telemetry/log_buffer.dart
@lib/src/services/telemetry/error_report_throttle.dart
@lib/src/services/telemetry/firebase_crashlytics_telemetry_service.dart
@lib/src/services/telemetry/telemetry_service.dart
@lib/main.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix LogBuffer size enforcement and add TelemetryReportQueue</name>
  <files>
    lib/src/services/telemetry/log_buffer.dart
    lib/src/services/telemetry/telemetry_report_queue.dart
  </files>
  <action>
**LogBuffer fix** (`log_buffer.dart`):
The `append()` method has a bug at line 40-46 — the `while` loop that should enforce maxSizeBytes breaks immediately on the first iteration, meaning size enforcement never actually happens. Fix by replacing the broken while loop with working eviction logic:

1. After adding the new entry and updating `_currentSizeBytes`, check if `_currentSizeBytes > maxSizeBytes`
2. If so, convert `_buffer` to a list, remove entries from the front until `_currentSizeBytes <= maxSizeBytes` (subtracting each removed entry's length from `_currentSizeBytes`)
3. Clear the buffer and re-add the remaining entries
4. This approach works around CircularBuffer's lack of `removeFirst()` (documented in 01-01-SUMMARY)

Keep the existing capacity-based auto-eviction in the first part of `append()` (lines 29-31) — it handles the common case. The byte-size trimming handles the edge case where many short entries fit within 500 capacity but exceed 16kb.

**TelemetryReportQueue** (`telemetry_report_queue.dart`):
Create a new class that provides bounded, async report sending:

```dart
class TelemetryReportQueue {
  // Bounded queue with max 10 pending reports
  // Each report: { error: Object, stackTrace: StackTrace?, fatal: bool }
  // FIFO eviction: when full, drop oldest (removeFirst) to make room for newest
  // Processing: use a simple async drain loop triggered by enqueue
  // - If already draining, just enqueue and return (the loop will pick it up)
  // - If not draining, start the drain loop
  // The drain loop processes one report at a time via the provided send callback
  // The send callback is a Future<void> Function(Object error, StackTrace? stackTrace, {bool fatal})
}
```

Constructor takes a `Future<void> Function(Object, StackTrace?, {bool fatal})` callback for actually sending reports. This keeps the queue decoupled from Firebase specifics.

Queue capacity: 10 reports (per user decision — bounded, FIFO eviction when full).

The drain loop should catch errors from the send callback and log them (via dart:developer log or just swallow) — a failed send should not crash the queue.

Do NOT use Isolates — this is a simple async queue using microtask scheduling. The queue is in-memory only (per user decision — app restart loses queued reports, acceptable).
  </action>
  <verify>
    Run `flutter analyze lib/src/services/telemetry/log_buffer.dart lib/src/services/telemetry/telemetry_report_queue.dart` — no errors or warnings.
  </verify>
  <done>
    LogBuffer.append() actually evicts oldest entries when _currentSizeBytes exceeds 16kb (no more premature break). TelemetryReportQueue exists with enqueue(), bounded capacity of 10, FIFO eviction, and async drain loop.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire report queue into FirebaseCrashlyticsTelemetryService and main.dart</name>
  <files>
    lib/src/services/telemetry/firebase_crashlytics_telemetry_service.dart
    lib/main.dart
  </files>
  <action>
**FirebaseCrashlyticsTelemetryService** changes:
1. Add a `TelemetryReportQueue` field initialized in the constructor
2. The queue's send callback should be a private method `_sendReport(Object error, StackTrace? stackTrace, {bool fatal})` that does the current `recordError` work: sets `log_buffer` custom key, then calls `FirebaseCrashlytics.instance.recordError()`
3. Change `recordError()` to enqueue via `_queue.enqueue(error, stackTrace, fatal: fatal)` instead of directly awaiting Firebase calls
4. The `recordError()` method becomes essentially non-blocking from the caller's perspective — it enqueues and returns quickly

**main.dart** changes:
The Logger.root listener (around line 174) currently calls `telemetryService.recordError(error, record.stackTrace)` — this call is already fire-and-forget (not awaited). With the queue change inside FirebaseCrashlyticsTelemetryService, no changes to main.dart's listener logic are needed. The queue is internal to the service.

However, verify that the `telemetryService.recordError()` call in main.dart is NOT being awaited. If it is, remove the await — the queue handles async processing internally.

No changes to the TelemetryService abstract interface — `recordError()` remains `Future<void>`. The semantic change is internal to the Firebase implementation.
  </action>
  <verify>
    Run `flutter analyze lib/src/services/telemetry/ lib/main.dart` — no errors or warnings.
  </verify>
  <done>
    FirebaseCrashlyticsTelemetryService.recordError() enqueues reports to the bounded queue instead of blocking on Firebase platform channel calls. The rate limiter in main.dart's Logger.root listener remains the first line of defense; the queue provides additional backpressure for reports that pass the rate limiter. No changes to TelemetryService interface.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze lib/src/services/telemetry/` passes with no errors
2. `flutter analyze lib/main.dart` passes with no errors
3. LogBuffer.append() contains actual eviction logic (no `break` in while loop)
4. TelemetryReportQueue has bounded capacity with FIFO eviction
5. FirebaseCrashlyticsTelemetryService.recordError() delegates to queue
</verification>

<success_criteria>
- LogBuffer byte-size enforcement works (oldest entries evicted when exceeding 16kb)
- Report queue caps at 10 pending reports with FIFO eviction
- recordError() is non-blocking from the caller's perspective
- Rate limiter → Queue → Firebase pipeline is in place
- All telemetry files pass flutter analyze
</success_criteria>

<output>
After completion, create `.planning/phases/03-performance-optimization/03-01-SUMMARY.md`
</output>
