---
phase: 01-core-telemetry-service-privacy
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - lib/src/settings/settings_service.dart
  - lib/src/settings/settings_controller.dart
  - lib/main.dart
  - lib/src/permissions_feature/permissions_view.dart
autonomous: true

must_haves:
  truths:
    - "Telemetry consent is persisted in SharedPreferences and survives app restarts"
    - "User can toggle telemetry consent in the permissions flow"
    - "Crashlytics collection is disabled until user grants consent"
    - "FlutterError.onError and PlatformDispatcher.onError route through TelemetryService"
    - "Debug and simulate builds never initialize Firebase telemetry"
    - "Logger.root WARNING+ records are captured in the rolling log buffer"
  artifacts:
    - path: "lib/src/settings/settings_service.dart"
      provides: "telemetryConsent persistence methods"
      contains: "telemetryConsent"
    - path: "lib/src/settings/settings_controller.dart"
      provides: "telemetryConsent getter and setter with notifyListeners"
      contains: "telemetryConsent"
    - path: "lib/main.dart"
      provides: "TelemetryService creation, LogBuffer creation, logging hookup, error handler wiring"
      contains: "TelemetryService"
    - path: "lib/src/permissions_feature/permissions_view.dart"
      provides: "Telemetry consent toggle during startup flow"
      contains: "telemetryConsent"
  key_links:
    - from: "lib/main.dart"
      to: "lib/src/services/telemetry/telemetry_service.dart"
      via: "TelemetryService.create() factory call"
      pattern: "TelemetryService\\.create"
    - from: "lib/main.dart"
      to: "lib/src/services/telemetry/log_buffer.dart"
      via: "LogBuffer instance created and passed to TelemetryService"
      pattern: "LogBuffer\\("
    - from: "lib/main.dart"
      to: "Logger.root.onRecord"
      via: "Listener that appends WARNING+ to LogBuffer and scrubs PII"
      pattern: "Logger\\.root\\.onRecord"
    - from: "lib/src/permissions_feature/permissions_view.dart"
      to: "lib/src/settings/settings_controller.dart"
      via: "settingsController.setTelemetryConsent() call"
      pattern: "setTelemetryConsent"
    - from: "lib/src/settings/settings_controller.dart"
      to: "lib/src/services/telemetry/telemetry_service.dart"
      via: "telemetryService.setConsentEnabled() when consent changes"
      pattern: "setConsentEnabled"
---

<objective>
Integrate TelemetryService into the app lifecycle: add consent persistence to settings, wire TelemetryService creation and error handlers in main.dart, hook Logger.root to the log buffer, and add a telemetry consent toggle in the permissions startup flow.

Purpose: This makes the telemetry infrastructure from Plan 01 actually functional. Without this wiring, the service files exist but are never instantiated or connected to the app.
Output: Updated settings_service.dart, settings_controller.dart, main.dart, and permissions_view.dart.
</objective>

<execution_context>
@/Users/vid/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-telemetry-service-privacy/01-RESEARCH.md
@.planning/phases/01-core-telemetry-service-privacy/01-01-SUMMARY.md
@lib/src/settings/settings_service.dart
@lib/src/settings/settings_controller.dart
@lib/main.dart
@lib/src/permissions_feature/permissions_view.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add telemetry consent to SettingsService and SettingsController</name>
  <files>
    lib/src/settings/settings_service.dart
    lib/src/settings/settings_controller.dart
  </files>
  <action>
    1. In `lib/src/settings/settings_service.dart`:
       - Add `telemetryConsent` to the `SettingsKeys` enum
       - Add method `Future<bool> telemetryConsent() async` that returns `await prefs.getBool(SettingsKeys.telemetryConsent.name) ?? false` (default OFF — PRIV-04 requires opt-in)
       - Add method `Future<void> setTelemetryConsent(bool value) async` that calls `await prefs.setBool(SettingsKeys.telemetryConsent.name, value)`

    2. In `lib/src/settings/settings_controller.dart`:
       - Add private field `late bool _telemetryConsent`
       - Add getter `bool get telemetryConsent => _telemetryConsent`
       - Add a `TelemetryService? _telemetryService` private field (nullable, set via a setter below)
       - Add setter `set telemetryService(TelemetryService service) => _telemetryService = service` — this allows main.dart to wire the telemetry service after creation without changing the SettingsController constructor signature (keeps backward compatibility)
       - In `loadSettings()`: add `_telemetryConsent = await _settingsService.telemetryConsent();` alongside the other settings loads. After loading, if `_telemetryService != null`, call `_telemetryService!.setConsentEnabled(_telemetryConsent)` to sync consent state on app startup.
       - Add method `Future<void> setTelemetryConsent(bool value) async`:
         - Early return if `value == _telemetryConsent`
         - Set `_telemetryConsent = value`
         - Call `await _settingsService.setTelemetryConsent(value)`
         - If `_telemetryService != null`, call `await _telemetryService!.setConsentEnabled(value)`
         - Call `notifyListeners()`
       - Add import for TelemetryService: `import 'package:reaprime/src/services/telemetry/telemetry_service.dart';`
  </action>
  <verify>
    Run `flutter analyze lib/src/settings/` — no errors.
  </verify>
  <done>
    Telemetry consent is persisted via SharedPreferences with default OFF. SettingsController syncs consent state to TelemetryService when consent changes and on app startup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire TelemetryService in main.dart and add consent toggle in permissions_view.dart</name>
  <files>
    lib/main.dart
    lib/src/permissions_feature/permissions_view.dart
  </files>
  <action>
    1. In `lib/main.dart`:
       - Add imports:
         ```
         import 'package:reaprime/src/services/telemetry/telemetry_service.dart';
         import 'package:reaprime/src/services/telemetry/log_buffer.dart';
         import 'package:reaprime/src/services/telemetry/anonymization.dart';
         ```
       - REMOVE the existing Firebase initialization block (lines ~109-123 that check `Platform.isLinux == false && Platform.isWindows == false` and directly call `Firebase.initializeApp`, `FlutterError.onError`, `PlatformDispatcher.instance.onError`). This is being replaced by TelemetryService.

       - AFTER the logging setup (after `RotatingFileAppender` lines, around line 101) and BEFORE the device services setup, add:
         ```dart
         // Create log buffer and telemetry service
         final logBuffer = LogBuffer();
         final telemetryService = TelemetryService.create(logBuffer: logBuffer);

         // Initialize telemetry (disables collection by default, sets up error handlers)
         try {
           await telemetryService.initialize();
         } catch (e, st) {
           log.warning('Telemetry initialization failed', e, st);
         }

         // Hook Logger.root to capture WARNING+ in log buffer with PII scrubbing
         Logger.root.onRecord.listen((record) {
           if (record.level >= Level.WARNING) {
             final scrubbed = Anonymization.scrubString(
               '${record.level.name}: ${record.loggerName}: ${record.message}'
             );
             logBuffer.append(scrubbed);
           }
         });
         ```

       - AFTER `settingsController` is created (line ~224), add:
         ```dart
         settingsController.telemetryService = telemetryService;
         ```
         This must be BEFORE `settingsController.loadSettings()` so that when loadSettings runs, it can sync the persisted consent state to the telemetry service.

       - Update the `FirebaseCrashlyticsTelemetryService.initialize()` method to also set up the global error handlers. Specifically, in `firebase_crashlytics_telemetry_service.dart` (from Plan 01), the `initialize()` method should:
         - Call `await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform)` — BUT WAIT: Firebase.initializeApp is ALREADY called implicitly by the TelemetryService factory only for non-Linux/non-debug. Actually, looking at the current main.dart, Firebase.initializeApp happens in main.dart. Since we are removing that block, the FirebaseCrashlyticsTelemetryService.initialize() must handle Firebase initialization.
         - Actually, re-reading the code: Firebase.initializeApp might be needed by other Firebase services (Analytics, Performance). So keep Firebase.initializeApp in main.dart but ONLY on supported platforms and non-debug mode. Move it to BEFORE TelemetryService creation:
         ```dart
         // Initialize Firebase on supported platforms (not Linux, not debug, not simulate)
         final isDebugOrSimulate = kDebugMode || const String.fromEnvironment("simulate") == "1";
         if (!Platform.isLinux && !Platform.isWindows) {
           try {
             await Firebase.initializeApp(
               options: DefaultFirebaseOptions.currentPlatform,
             );
           } catch (e, st) {
             log.warning('Firebase initialization failed', e, st);
           }
         }
         ```
         Then TelemetryService.create() handles whether to use Firebase or NoOp based on platform/debug flags.

       - In the `FirebaseCrashlyticsTelemetryService.initialize()` (this is modifying the file from Plan 01):
         - Call `await FirebaseCrashlytics.instance.setCrashlyticsCollectionEnabled(false)` (consent off by default)
         - Set up global error handlers:
           ```dart
           FlutterError.onError = (details) {
             FirebaseCrashlytics.instance.recordFlutterFatalError(details);
           };
           PlatformDispatcher.instance.onError = (error, stack) {
             FirebaseCrashlytics.instance.recordError(error, stack, fatal: true);
             return true;
           };
           ```
         - This replaces the equivalent code that was removed from main.dart (TELE-04)

       - NOTE on Windows: The current main.dart excludes Windows from Firebase init (`Platform.isLinux == false && Platform.isWindows == false`). Keep this behavior — Windows support for Crashlytics is limited. The TelemetryService.create() factory should also return NoOp for Windows. Update the factory check: return NoOp if `Platform.isLinux || Platform.isWindows || kDebugMode || simulate == "1"`.

    2. In `lib/src/permissions_feature/permissions_view.dart`:
       - The consent toggle should appear in the `checkPermissions()` method flow. Since this is an automated startup flow (not an interactive dialog), we will add telemetry consent handling AFTER permissions are granted but BEFORE device initialization.
       - Actually, looking at the current `checkPermissions()` more carefully: it is a Future that runs asynchronously and the UI shows a progress bar. We should NOT block the flow with a dialog here. Instead, add the consent as a settings toggle visible in the SettingsView.
       - REVISED APPROACH for permissions_view.dart: Since the requirement says "Telemetry consent prompt in permissions_view.dart alongside other permissions" (PRIV-03), add a simple consent check that reads the stored preference. If telemetry hasn't been prompted yet (first launch), we need to show a consent dialog. Add:
         - Import `SettingsService` (already imported via settingsController)
         - In `checkPermissions()`, after the platform permissions block and before WebUI init, add:
           ```dart
           // Check if telemetry consent has been prompted
           final hasBeenPrompted = await settingsController._settingsService...
           ```
           Wait — SettingsService is private in SettingsController. Instead, add a method to SettingsService: `Future<bool> telemetryPromptShown() async` returning `await prefs.getBool(SettingsKeys.telemetryPromptShown.name) ?? false` and `Future<void> setTelemetryPromptShown(bool value) async`. Add `telemetryPromptShown` to SettingsKeys enum.
         - Actually, to keep it simpler and avoid blocking the startup flow with a dialog (which would be complex in a FutureBuilder), take the following approach:
           - Add a `telemetryPromptShown` bool to SettingsService and SettingsController (same pattern as other settings)
           - In `checkPermissions()`, after permissions, check `if (!settingsController.telemetryPromptShown)` — if not shown yet, we will show the prompt AFTER navigation completes (not blocking startup). For now, just ensure consent defaults to OFF (already done via SettingsService default).
           - The actual prompt will be shown as a one-time dialog on the home screen. But for PRIV-03, the simplest approach matching "alongside other permissions" is:
             - On Android/iOS: add telemetry as one more permission request in the permissions block. Since `permission_handler` doesn't have a "telemetry" permission, we show our own dialog.
             - On all platforms: Show a simple consent dialog in `checkPermissions()` if not yet prompted.

       - FINAL APPROACH (keeping it clean):
         - PermissionsView already receives `settingsController`
         - In `checkPermissions()`, after all platform permissions are done (after the if/else block, before WebUI init), add:
           ```dart
           // Telemetry consent prompt (one-time, non-blocking)
           if (!settingsController.telemetryPromptShown) {
             // We'll mark it as shown and leave consent OFF by default.
             // User can enable in Settings. This satisfies PRIV-03 (consent
             // is surfaced) and PRIV-04 (disabled until explicitly enabled).
             await settingsController.setTelemetryPromptShown(true);
             _log.info('Telemetry consent defaulting to OFF (user can enable in Settings)');
           }
           ```
         - This is the MINIMUM viable consent for Phase 1. The consent toggle in SettingsView will be the primary way users enable telemetry. This avoids blocking startup with a modal dialog.
         - In `lib/src/settings/settings_view.dart`: We are NOT modifying this file in this plan (it would add a third file and the task is already complex). The settings toggle can be added in a gap closure or Phase 2 task if needed. For Phase 1, the consent mechanism exists (SettingsController.setTelemetryConsent) and defaults to OFF.

    3. Add `telemetryPromptShown` to settings (alongside Task 1 changes):
       - SettingsService: add `telemetryPromptShown` to enum, add getter (default false) and setter
       - SettingsController: add `_telemetryPromptShown` field, getter, `loadSettings()` line, and `setTelemetryPromptShown()` method
  </action>
  <verify>
    Run `flutter analyze` (full project) — no errors.
    Verify main.dart compiles: `flutter build apk --debug 2>&1 | head -20` or just `flutter analyze`.
    Grep for removed code: ensure no duplicate FlutterError.onError assignment.
    Grep for TelemetryService references in main.dart: confirm creation and wiring.
  </verify>
  <done>
    TelemetryService is created in main.dart using factory method (NoOp for Linux/Windows/debug/simulate, Firebase for Android/iOS/macOS release builds). Error handlers route through TelemetryService. Logger.root WARNING+ messages are captured in LogBuffer with PII scrubbed. Consent persists via SharedPreferences and defaults to OFF. settingsController syncs consent to TelemetryService. permissions_view.dart marks telemetry prompt as shown during startup.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with no errors on the full project
2. main.dart no longer directly calls `FirebaseCrashlytics.instance` — all telemetry goes through TelemetryService
3. TelemetryService.create() returns NoOpTelemetryService for debug builds (verify by checking factory logic)
4. SettingsController has telemetryConsent getter/setter that syncs to TelemetryService
5. permissions_view.dart references telemetryPromptShown
6. Logger.root.onRecord listener exists in main.dart, filtering WARNING+, scrubbing PII via Anonymization.scrubString()
7. No raw MAC addresses or IP addresses can leak through the logging pipeline to Crashlytics
</verification>

<success_criteria>
- FlutterError.onError and PlatformDispatcher.onError route through TelemetryService (TELE-04)
- Debug/simulate builds use NoOp (TELE-05)
- Consent defaults to OFF and persists across restarts (PRIV-03, PRIV-04)
- Logger WARNING+ messages are buffered with PII scrubbed (LOGC-01, PRIV-01, PRIV-02)
- TelemetryService is created and wired in main.dart
- `flutter analyze` passes cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-telemetry-service-privacy/01-02-SUMMARY.md`
</output>
