---
phase: 04-webview-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/src/services/webview_log_service.dart
  - lib/src/skin_feature/skin_view.dart
  - lib/main.dart
autonomous: true

must_haves:
  truths:
    - "WebView console output (log, warn, error, debug, info) is captured and written to webview_console.log"
    - "WebView logs are isolated from app logs — separate file, never cross into package:logging or telemetry"
    - "Log entries include timestamp, skin ID, level, and message"
    - "Log file is cleared on app restart"
    - "Log file is capped at 1MB with oldest-half truncation"
  artifacts:
    - path: "lib/src/services/webview_log_service.dart"
      provides: "WebView console log capture, file writing, stream broadcasting"
      contains: "class WebViewLogService"
    - path: "lib/src/skin_feature/skin_view.dart"
      provides: "onConsoleMessage hook routing to WebViewLogService"
      contains: "webViewLogService"
    - path: "lib/main.dart"
      provides: "WebViewLogService instantiation and injection"
      contains: "WebViewLogService"
  key_links:
    - from: "lib/src/skin_feature/skin_view.dart"
      to: "lib/src/services/webview_log_service.dart"
      via: "onConsoleMessage callback calling webViewLogService.log()"
      pattern: "webViewLogService\\.log"
    - from: "lib/main.dart"
      to: "lib/src/services/webview_log_service.dart"
      via: "instantiation and passing to SkinView/webserver"
      pattern: "WebViewLogService"
---

<objective>
Create the WebViewLogService and hook it into SkinView's onConsoleMessage callback to capture all JavaScript console output from WebUI skins.

Purpose: Establish the core log capture pipeline — console messages from skins flow through WebViewLogService to a dedicated log file, completely isolated from app logs.
Output: WebViewLogService class, updated SkinView with console capture, initialization in main.dart
</objective>

<execution_context>
@/Users/vid/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@lib/src/skin_feature/skin_view.dart
@lib/src/services/telemetry/log_buffer.dart
@lib/main.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebViewLogService</name>
  <files>lib/src/services/webview_log_service.dart</files>
  <action>
Create a new standalone service class (NOT a part file — this is a separate service, not a webserver handler).

```dart
class WebViewLogService {
  // Constructor takes log directory path (resolved in main.dart)
  WebViewLogService({required String logDirectoryPath});

  // Public API:
  // - log(String skinId, String level, String message) — formats and writes entry
  // - Stream<String> get stream — broadcasts formatted log entries for WebSocket consumers
  // - String getContents() — returns full file contents for REST endpoint
  // - Future<void> initialize() — creates/clears the log file on startup
  // - void dispose() — closes stream controller
}
```

**Implementation details:**

1. **Log file path:** `{logDirectoryPath}/webview_console.log`
   - On Android: `/storage/emulated/0/Download/REA1/webview_console.log`
   - On other platforms: `{appDocumentsDir}/webview_console.log`
   - Path resolved externally (in main.dart), passed via constructor

2. **initialize():** Create or truncate the log file (clear on app restart per CONTEXT decision)

3. **log(skinId, level, message):**
   - Format: `[ISO8601_TIMESTAMP] [skinId] [LEVEL] message\n`
   - Append to file (use IOSink for efficient appending, opened once in initialize)
   - Add formatted string to StreamController.broadcast for WebSocket consumers
   - Check file size after write — if > 1MB, truncate (keep second half of file)

4. **Size enforcement (1MB cap):**
   - After each write, check file size via File.lengthSync()
   - If > 1,048,576 bytes: read file, keep second half, rewrite, reopen IOSink
   - This is infrequent (only triggers at 1MB boundary), so sync read is acceptable

5. **getContents():** Read and return full file as string (for REST endpoint)

6. **stream:** StreamController.broadcast — no buffering, just live events

7. **dispose():** Close IOSink and StreamController

Use `package:logging` Logger internally for service-level logging (e.g., "WebViewLogService initialized", "truncated log file").
Do NOT route captured webview messages through package:logging — they go directly to file + stream.
  </action>
  <verify>
File exists at lib/src/services/webview_log_service.dart.
`flutter analyze lib/src/services/webview_log_service.dart` passes with no errors.
Class has: constructor with logDirectoryPath, initialize(), log(), getContents(), stream getter, dispose().
  </verify>
  <done>
WebViewLogService class exists with file-based logging, 1MB size cap, stream broadcasting, and app-restart file clearing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Hook SkinView and wire in main.dart</name>
  <files>lib/src/skin_feature/skin_view.dart, lib/main.dart</files>
  <action>
**Part A: Update SkinView to use WebViewLogService**

1. Add WebViewLogService parameter to SkinView constructor:
   ```dart
   class SkinView extends StatefulWidget {
     const SkinView({super.key, required this.settingsController, required this.webViewLogService});
     final SettingsController settingsController;
     final WebViewLogService webViewLogService;
   ```

2. Update the existing `onConsoleMessage` callback (currently at ~line 485-489 in skin_view.dart) to route through WebViewLogService instead of just logging at FINEST:
   ```dart
   onConsoleMessage: (controller, consoleMessage) {
     // Determine skin ID from settings or default
     final skinId = widget.settingsController.defaultSkinId ?? 'unknown';
     widget.webViewLogService.log(
       skinId,
       consoleMessage.messageLevel.toString(),
       consoleMessage.message,
     );
   },
   ```

3. Keep existing `_log.finest(...)` call as well for backward compatibility — the app logger should still see webview messages at FINEST level for debugging purposes. Place it AFTER the webViewLogService.log() call.

**Part B: Instantiate WebViewLogService in main.dart**

1. Import webview_log_service.dart in main.dart
2. After the existing log file setup block (around line 137), create and initialize WebViewLogService:
   ```dart
   // Resolve log directory for webview console logs
   final webViewLogDir = Platform.isAndroid
       ? '/storage/emulated/0/Download/REA1'
       : (await getApplicationDocumentsDirectory()).path;
   final webViewLogService = WebViewLogService(logDirectoryPath: webViewLogDir);
   await webViewLogService.initialize();
   ```

3. Pass `webViewLogService` through to where SkinView is constructed. Look at how the app routes are set up — SkinView is constructed in `app.dart` routing. The webViewLogService needs to be accessible there. Follow the same pattern used for settingsController (passed through MyApp → MaterialApp routes).

4. Also pass `webViewLogService` to `startWebServer()` — it will be needed by Plan 02 for REST/WS endpoints. Add the parameter to the function signature now (even though the handler doesn't exist yet) so Plan 02 doesn't need to modify main.dart.

**Part C: Update app.dart routing**

Find where SkinView is instantiated in the routing (app.dart) and pass the webViewLogService. Follow the existing pattern for settingsController injection.
  </action>
  <verify>
`flutter analyze` passes with no errors across all modified files.
SkinView constructor requires webViewLogService parameter.
onConsoleMessage callback writes to both webViewLogService and existing _log.finest.
main.dart creates and initializes WebViewLogService.
startWebServer signature includes WebViewLogService parameter.
  </verify>
  <done>
WebView console messages flow from SkinView → WebViewLogService → webview_console.log file + broadcast stream. Service is initialized in main.dart and wired to both SkinView and webserver.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with no errors
2. WebViewLogService class exists with all required methods
3. SkinView's onConsoleMessage routes through WebViewLogService
4. main.dart creates, initializes, and injects WebViewLogService
5. WebView logs never enter package:logging WARNING+ pipeline (isolated from telemetry)
6. Log entries formatted as `[timestamp] [skinId] [level] message`
</verification>

<success_criteria>
- WebViewLogService exists and can write to webview_console.log
- SkinView captures ALL console levels via onConsoleMessage
- Log file is cleared on app startup
- 1MB size cap with oldest-half truncation
- Stream broadcasts each log entry for future WebSocket consumers
- App compiles and analyzes clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-webview-integration/04-01-SUMMARY.md`
</output>
