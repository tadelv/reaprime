---
phase: 04-webview-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - lib/src/services/webserver/webview_logs_handler.dart
  - lib/src/services/webserver_service.dart
  - lib/src/services/feedback_service.dart
autonomous: true

must_haves:
  truths:
    - "GET /api/v1/webview/logs returns raw webview_console.log contents as plain text"
    - "ws/v1/webview/logs streams live webview console entries to connected WebSocket clients"
    - "WebView logs are included in user feedback submissions alongside app logs"
    - "REST and WebSocket endpoints are isolated from existing /api/v1/logs and ws/v1/logs"
  artifacts:
    - path: "lib/src/services/webserver/webview_logs_handler.dart"
      provides: "REST and WebSocket endpoints for webview logs"
      contains: "class WebViewLogsHandler"
    - path: "lib/src/services/webserver_service.dart"
      provides: "WebViewLogsHandler wiring into webserver"
      contains: "webViewLogsHandler"
    - path: "lib/src/services/feedback_service.dart"
      provides: "Webview log inclusion in feedback submissions"
      contains: "webview_console"
  key_links:
    - from: "lib/src/services/webserver/webview_logs_handler.dart"
      to: "lib/src/services/webview_log_service.dart"
      via: "constructor injection of WebViewLogService"
      pattern: "WebViewLogService"
    - from: "lib/src/services/feedback_service.dart"
      to: "webview_console.log"
      via: "_readWebViewLogFile reading dedicated log file"
      pattern: "webview_console\\.log"
---

<objective>
Expose webview logs via REST and WebSocket API endpoints and integrate them into the user feedback flow.

Purpose: Skin developers can stream live console output during development via WebSocket. REST endpoint provides on-demand log access. Feedback submissions include webview logs for complete debugging context.
Output: WebViewLogsHandler with REST + WS endpoints, updated FeedbackService with webview log inclusion
</objective>

<execution_context>
@/Users/vid/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-webview-integration/04-01-SUMMARY.md
@lib/src/services/webserver/logs_handler.dart
@lib/src/services/webserver/settings_handler.dart
@lib/src/services/webserver_service.dart
@lib/src/services/feedback_service.dart
@lib/src/services/webview_log_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WebViewLogsHandler with REST and WebSocket endpoints</name>
  <files>lib/src/services/webserver/webview_logs_handler.dart, lib/src/services/webserver_service.dart</files>
  <action>
**Part A: Create WebViewLogsHandler**

Create as a `part of '../webserver_service.dart';` file (follows existing handler pattern: logs_handler.dart, feedback_handler.dart, etc.).

```dart
part of '../webserver_service.dart';

/// REST and WebSocket handler for WebView console logs
class WebViewLogsHandler {
  final WebViewLogService _webViewLogService;

  WebViewLogsHandler({required WebViewLogService webViewLogService})
      : _webViewLogService = webViewLogService;

  void addRoutes(RouterPlus app) {
    // REST: raw log file contents
    app.get('/api/v1/webview/logs', _handleGetLogs);
    // WebSocket: live stream
    app.get('/ws/v1/webview/logs', _handleWebSocketLogs);
  }
```

1. **GET /api/v1/webview/logs:**
   - Returns `_webViewLogService.getContents()` as `text/plain`
   - Pattern matches existing LogsHandler._handleGetLogs exactly
   - Response 200 with raw text content

2. **ws/v1/webview/logs:**
   - Use `sws.webSocketHandler` (same as existing ws/v1/logs in settings_handler.dart)
   - Subscribe to `_webViewLogService.stream`
   - For each entry, send JSON to WebSocket client:
     ```json
     {"timestamp": "...", "skinId": "...", "level": "...", "message": "..."}
     ```
   - Parse the formatted log line `[timestamp] [skinId] [level] message` to extract fields for JSON
   - OR: simpler approach — send the raw formatted string as-is (consistent with how console capture works). Skin developers can parse if needed. Use this simpler approach.
   - Cancel stream subscription on socket close/error

**Part B: Wire into webserver_service.dart**

1. Add `part 'webserver/webview_logs_handler.dart';` directive alongside existing part directives
2. Import WebViewLogService at top of webserver_service.dart
3. Add `WebViewLogService webViewLogService` parameter to `startWebServer()` function signature
4. Create `WebViewLogsHandler` instance in startWebServer:
   ```dart
   final webViewLogsHandler = WebViewLogsHandler(webViewLogService: webViewLogService);
   ```
5. Pass to `_init()` — add parameter and call `webViewLogsHandler.addRoutes(app)`
6. Follow the exact same pattern as how LogsHandler is wired (it's the most recent addition and closest analog)
  </action>
  <verify>
`flutter analyze` passes.
`/api/v1/webview/logs` route registered in handler.
`/ws/v1/webview/logs` route registered in handler.
webserver_service.dart has part directive and passes WebViewLogService through.
startWebServer signature includes WebViewLogService parameter.
  </verify>
  <done>
GET /api/v1/webview/logs returns raw webview console log contents. ws/v1/webview/logs streams live entries to WebSocket clients. Both endpoints are fully isolated from existing /api/v1/logs and ws/v1/logs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Include webview logs in feedback submissions</name>
  <files>lib/src/services/feedback_service.dart</files>
  <action>
Update FeedbackService to include webview_console.log in feedback Gist uploads alongside the existing app log.

1. **Add `_readWebViewLogFile()` method** — follows the exact pattern of existing `_readLogFile()` (line 173-192):
   ```dart
   Future<String?> _readWebViewLogFile() async {
     try {
       if (Platform.isAndroid) {
         final androidFile = File('/storage/emulated/0/Download/REA1/webview_console.log');
         if (await androidFile.exists()) {
           return await androidFile.readAsString();
         }
       }
       final docs = await getApplicationDocumentsDirectory();
       final logFile = File('${docs.path}/webview_console.log');
       if (await logFile.exists()) {
         return await logFile.readAsString();
       }
       _log.info('No webview log file found');
       return null;
     } catch (e) {
       _log.warning('Failed to read webview log file', e);
       return null;
     }
   }
   ```

2. **Update `_uploadGist()`** to include webview logs:
   - After the existing app logs block (~line 120-130), add:
   ```dart
   // Add webview console logs if available
   String? webViewLogContent = await _readWebViewLogFile();
   if (webViewLogContent != null && webViewLogContent.isNotEmpty) {
     const maxWebViewLogSize = 500000; // ~500KB
     if (webViewLogContent.length > maxWebViewLogSize) {
       webViewLogContent = '... (truncated) ...\n${webViewLogContent.substring(webViewLogContent.length - maxWebViewLogSize)}';
     }
     gistFiles['reaprime_webview_logs.txt'] = {'content': webViewLogContent};
   }
   ```

3. **Update `generateHtmlReport()`** to include webview logs section:
   - After the existing app logs section (~line 399-409), add a "WebView Console Logs" section:
   ```dart
   String? webViewLogContent;
   if (request.includeLogs) {
     webViewLogContent = await _readWebViewLogFile();
   }
   // ... (in the HTML generation section, after app logs)
   if (webViewLogContent != null && webViewLogContent.isNotEmpty) {
     // Truncate for HTML
     const maxWebViewLogSize = 100000;
     if (webViewLogContent.length > maxWebViewLogSize) {
       webViewLogContent = '... (truncated) ...\n${webViewLogContent.substring(webViewLogContent.length - maxWebViewLogSize)}';
     }
     html.writeln('<h2>WebView Console Logs</h2>');
     html.writeln('<pre>${_escapeHtml(webViewLogContent)}</pre>');
   }
   ```

4. The inclusion is automatic when `includeLogs: true` — no new flag needed. WebView logs piggyback on the existing logs opt-in since they contain skin developer debug output (no PII concern).
  </action>
  <verify>
`flutter analyze` passes.
_readWebViewLogFile() method exists in FeedbackService.
_uploadGist() includes webview_console.log in gist files.
generateHtmlReport() includes WebView Console Logs section.
  </verify>
  <done>
User feedback submissions include webview_console.log alongside app logs when includeLogs is true. Both Gist uploads and HTML reports contain a separate "WebView Console Logs" section.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze` passes with no errors
2. GET /api/v1/webview/logs returns plain text webview log contents
3. ws/v1/webview/logs streams live entries via WebSocket
4. WebView logs appear in feedback Gist as `reaprime_webview_logs.txt`
5. WebView logs appear in HTML feedback report under "WebView Console Logs" heading
6. All new endpoints are separate from existing /api/v1/logs and ws/v1/logs
</verification>

<success_criteria>
- REST endpoint returns raw webview log file contents
- WebSocket endpoint streams live entries from WebViewLogService.stream
- Feedback service reads webview_console.log alongside log.txt
- Both Gist and HTML reports include webview logs when includeLogs is true
- No interference with existing log endpoints or telemetry pipeline
- App compiles and analyzes clean
</success_criteria>

<output>
After completion, create `.planning/phases/04-webview-integration/04-02-SUMMARY.md`
</output>
