---
phase: 02-integration-error-detection
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - lib/main.dart
  - lib/src/services/telemetry/error_report_throttle.dart
  - lib/src/controllers/device_controller.dart
autonomous: true

must_haves:
  truths:
    - "WARNING+ log messages automatically trigger non-fatal error reports to telemetry"
    - "Duplicate errors are rate-limited to max 1 report per 60s per unique message"
    - "Every error report includes the 16kb rolling log buffer for debugging context"
    - "Connected device snapshots (type, connection state) appear as custom keys in reports"
    - "Custom keys update automatically on device connect/disconnect events"
  artifacts:
    - path: "lib/src/services/telemetry/error_report_throttle.dart"
      provides: "Rate limiting logic for error reports"
      contains: "class ErrorReportThrottle"
    - path: "lib/main.dart"
      provides: "Logger.root listener calling telemetryService.recordError"
      contains: "telemetryService.recordError"
    - path: "lib/src/controllers/device_controller.dart"
      provides: "Device custom key updates on connect/disconnect"
      contains: "telemetryService"
  key_links:
    - from: "lib/main.dart"
      to: "lib/src/services/telemetry/telemetry_service.dart"
      via: "Logger.root.onRecord calls recordError through throttle"
      pattern: "telemetryService\\.recordError"
    - from: "lib/src/controllers/device_controller.dart"
      to: "lib/src/services/telemetry/telemetry_service.dart"
      via: "setCustomKey on device state changes"
      pattern: "_telemetryService\\.setCustomKey"
---

<objective>
Wire the global error reporting pipeline: enhance the existing Logger.root listener to call telemetryService.recordError() on WARNING+ with rate limiting, and inject TelemetryService into DeviceController for always-updated device state custom keys.

Purpose: This is the core error detection mechanism. Every WARNING+ log from any component (BLE, API, plugins, etc.) automatically produces a non-fatal error report with full log context. Device state is always up-to-date in reports via custom keys updated on connect/disconnect. Rate limiting prevents flooding Firebase.

Output: Working error reporting pipeline where log warnings trigger telemetry reports with device context.
</objective>

<execution_context>
@/Users/vid/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vid/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-telemetry-service-privacy/01-02-SUMMARY.md

@lib/src/services/telemetry/telemetry_service.dart
@lib/src/services/telemetry/firebase_crashlytics_telemetry_service.dart
@lib/src/services/telemetry/log_buffer.dart
@lib/src/services/telemetry/anonymization.dart
@lib/main.dart
@lib/src/controllers/device_controller.dart
@lib/src/models/device/device.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ErrorReportThrottle and enhance Logger.root listener to trigger telemetry reports</name>
  <files>
    lib/src/services/telemetry/error_report_throttle.dart
    lib/main.dart
  </files>
  <action>
Create `lib/src/services/telemetry/error_report_throttle.dart`:
- Class `ErrorReportThrottle` that enforces max 1 report per 60 seconds per unique error message.
- Internal `Map<String, DateTime> _lastReported` tracking when each unique message was last reported.
- Method `bool shouldReport(String message)` that returns true if no entry exists or if 60+ seconds have elapsed since the last report for that message. When returning true, update the timestamp.
- Method `void cleanup()` that removes entries older than 5 minutes to prevent unbounded map growth. Call cleanup() inside shouldReport() when map exceeds 100 entries.

Enhance the existing `Logger.root.onRecord.listen` block in `lib/main.dart` (around line 136-143):
- The existing listener already captures WARNING+ and appends scrubbed messages to logBuffer. Keep that behavior.
- After appending to logBuffer, add: if `throttle.shouldReport(scrubbed)` returns true, call `telemetryService.recordError(record.error ?? record.message, record.stackTrace)` as a non-fatal error.
- If `record.error` is non-null, use it as the error object; otherwise use the scrubbed message string.
- Create the `ErrorReportThrottle` instance near the `logBuffer` creation (around line 125).
- The telemetryService variable is already in scope from line 126.

Important: The existing listener already does PII scrubbing via `Anonymization.scrubString()`. Do NOT duplicate that. The recordError call uses the already-scrubbed message when no error object exists.
  </action>
  <verify>
Run `flutter analyze lib/src/services/telemetry/error_report_throttle.dart lib/main.dart` -- no errors.
Verify ErrorReportThrottle class exists with shouldReport() and cleanup() methods.
Verify main.dart Logger.root listener calls telemetryService.recordError.
  </verify>
  <done>
WARNING+ log records trigger telemetryService.recordError() with rate limiting (max 1 per 60s per unique message). Log buffer is already attached to error reports by FirebaseCrashlyticsTelemetryService.recordError(). ERRD-01, ERRD-02, ERRD-03, LOGC-02 satisfied.
  </done>
</task>

<task type="auto">
  <name>Task 2: Inject TelemetryService into DeviceController for device state custom keys</name>
  <files>
    lib/src/controllers/device_controller.dart
    lib/main.dart
  </files>
  <action>
Modify `lib/src/controllers/device_controller.dart`:
- Add an optional `TelemetryService? _telemetryService` field.
- Add a setter `set telemetryService(TelemetryService service)` following the same setter injection pattern used in SettingsController (Phase 1 decision).
- In the `_serviceUpdate` method (line 94), after updating `_devices[service] = devices` and emitting to the stream, call a new private method `_updateDeviceCustomKeys()`.
- Create `_updateDeviceCustomKeys()` that:
  - Iterates over all current devices (from `this.devices` getter).
  - For each device, calls `_telemetryService?.setCustomKey('device_${device.name}_type', device.type.name)`.
  - Counts connected devices by type (machine, scale, sensor) and sets summary keys:
    - `_telemetryService?.setCustomKey('connected_machines', machineCount)`
    - `_telemetryService?.setCustomKey('connected_scales', scaleCount)`
    - `_telemetryService?.setCustomKey('connected_sensors', sensorCount)`
  - To determine connection state for the summary counts, use the last known state. Since connectionState is a Stream, keep it simple: count all devices in the `_devices` map as "connected" (they only appear in the map when discovered/connected). The discovery services emit devices when they connect and remove them on disconnect.
- Import TelemetryService: `import 'package:reaprime/src/services/telemetry/telemetry_service.dart';`

Modify `lib/main.dart`:
- After creating `deviceController` (line 253), add: `deviceController.telemetryService = telemetryService;`
- This follows the same pattern as `settingsController.telemetryService = telemetryService;` on line 245.

Per user decision: use only existing fields (device.type, device.name). No RSSI or other fields that don't exist on transport interfaces.
  </action>
  <verify>
Run `flutter analyze lib/src/controllers/device_controller.dart lib/main.dart` -- no errors.
Verify DeviceController has telemetryService setter and _updateDeviceCustomKeys method.
Verify main.dart wires telemetryService into deviceController.
  </verify>
  <done>
Device state custom keys (device type, connected counts) are automatically updated on every device connect/disconnect event. Every subsequent error report automatically includes the latest device state. LOGC-04, LOGC-05, INTG-01 (via global listener), INTG-02 (via global listener) satisfied.
  </done>
</task>

</tasks>

<verification>
1. `flutter analyze lib/src/services/telemetry/ lib/main.dart lib/src/controllers/device_controller.dart` passes with no errors
2. ErrorReportThrottle correctly rate-limits: calling shouldReport("same message") returns true first time, false within 60s
3. Logger.root.onRecord listener in main.dart calls both logBuffer.append() AND telemetryService.recordError()
4. DeviceController._updateDeviceCustomKeys() is called from _serviceUpdate() on every device list change
5. DeviceController.telemetryService is set in main.dart before deviceController.initialize() would run
</verification>

<success_criteria>
- WARNING+ log messages from any component trigger non-fatal error reports via the global Logger.root listener
- Rate limiting prevents more than 1 report per 60 seconds per unique error message
- Each error report includes the 16kb rolling log buffer (already attached by FirebaseCrashlyticsTelemetryService.recordError)
- Connected device snapshots appear as custom keys updated on every device state change
- No per-component telemetry injection needed -- global listener covers all components using package:logging
</success_criteria>

<output>
After completion, create `.planning/phases/02-integration-error-detection/02-01-SUMMARY.md`
</output>
